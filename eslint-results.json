[{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/app.controller.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/app.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/app.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/app.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/auth/auth.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/auth/auth.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/auth/stateless-auth.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/auth/user-profile.service.cache.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/auth/user-profile.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache-evict.interceptor.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache-evict.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache-invalidation.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.interceptor.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/cache.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/decorators/cache.decorator.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/cache/decorators/cache.decorator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/common.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/dto/api-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/exceptions/business.exception.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/exceptions/business.exception.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/filters/global-exception.filter.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/filters/global-exception.filter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/interfaces/base-repository.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/logging/logger.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/logging/logging.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/logging/logging.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/logging/winston.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/middleware/correlation-id.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/middleware/logging.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/utils/error.utils.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/common/utils/error.utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/database/database.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/database/prisma.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/controllers/food.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/dto/create-food.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/dto/food-query.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/dto/food-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/dto/update-food.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/food.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/interfaces/openfoodfacts.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/repositories/food.repository.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/repositories/food.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/services/food.service.cache.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/services/food.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/services/food.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/services/openfoodfacts.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/food/services/openfoodfacts.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/database.health.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/database.health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/health.controller.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/health.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/health.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/health.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/health.service.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":132,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":171,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":171,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":206,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/openfoodfacts.health.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/health/openfoodfacts.health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/metrics.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/metrics.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/metrics.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/monitoring.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/monitoring.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/performance.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/performance.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/monitoring/performance.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/config/environment.validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/guards/rate-limit.guard.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/guards/rate-limit.guard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/middleware/security.middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/pipes/input-sanitization.pipe.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/pipes/input-sanitization.pipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/security.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/security.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/security/security.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/controllers/shoppingList.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/dto/create-shoppingList.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/dto/shoppingList-query.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/dto/shoppingList-response.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/dto/update.shoppingList.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/repositories/shoppingList.repository.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/repositories/shoppingList.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/services/shoppingList.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/services/shoppingList.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'query' is defined but never used.","line":49,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":49,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  BadRequestException,\n  ForbiddenException,\n  Injectable,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport { ShoppingListRepository } from '../repositories/shoppingList.repository';\nimport { CreateShoppingListDto } from '../dto/create-shoppingList.dto';\nimport {\n  MultipleShoppingListResponseDto,\n  ShoppingListResponseDto,\n} from '../dto/shoppingList-response.dto';\nimport { plainToClass, plainToInstance } from 'class-transformer';\nimport { ShoppingListQueryDto } from '../dto/shoppingList-query.dto';\nimport { UpdateShoppingListDto } from '../dto/update.shoppingList.dto';\n\n@Injectable()\nexport class ShoppingListService {\n  private readonly logger = new Logger(ShoppingListService.name);\n\n  constructor(\n    private readonly shoppingListRepository: ShoppingListRepository,\n  ) {}\n\n  async create(\n    createShoppingListDto: CreateShoppingListDto,\n    userId: string,\n  ): Promise<ShoppingListResponseDto> {\n    this.logger.log(`Creating a shopping list: ${createShoppingListDto.title}`);\n\n    try {\n      const shoppingList = await this.shoppingListRepository.create({\n        ...createShoppingListDto,\n        userId,\n      });\n      return this.transformToResponseDto(shoppingList);\n    } catch (error: any) {\n      if (error.code === 'P2002') {\n        throw new BadRequestException(\n          'Shopping list with this title already exists',\n        );\n      }\n      throw error;\n    }\n  }\n\n  async findAll(\n    query: ShoppingListQueryDto,\n  ): Promise<MultipleShoppingListResponseDto> {\n    this.logger.log(`Finding all shopping list `);\n\n    const shoppingList = await this.shoppingListRepository.findAll();\n\n    const transformedData = plainToInstance(\n      ShoppingListResponseDto,\n      shoppingList,\n      { excludeExtraneousValues: true },\n    );\n\n    return {\n      data: transformedData,\n    };\n  }\n\n  async findById(\n    id: string,\n    userId?: string,\n  ): Promise<ShoppingListResponseDto> {\n    this.logger.log(`Finding shopping list with the id:` + id);\n\n    const shoppingList = await this.shoppingListRepository.findById(id);\n\n    if (!shoppingList) {\n      throw new NotFoundException('Shopping list dosent exist');\n    }\n\n    if (shoppingList.userId !== userId) {\n      throw new ForbiddenException('No premission');\n    }\n    return this.transformToResponseDto(shoppingList);\n  }\n\n  async update(\n    id: string,\n    updateShoppingListDto: UpdateShoppingListDto,\n    userId?: string,\n  ): Promise<ShoppingListResponseDto> {\n    try {\n      const existingList = await this.shoppingListRepository.findById(id);\n      if (!existingList) {\n        throw new NotFoundException('Shopping list not found');\n      }\n      if (existingList.userId !== userId) {\n        throw new ForbiddenException('No premission');\n      }\n\n      const shoppingList = await this.shoppingListRepository.update(\n        id,\n        updateShoppingListDto,\n      );\n      return this.transformToResponseDto(shoppingList);\n    } catch (error) {\n      if (\n        error instanceof NotFoundException ||\n        error instanceof ForbiddenException\n      ) {\n        throw error;\n      }\n      throw new BadRequestException('Failed to update shopping list');\n    }\n  }\n\n  async remove(id: string, userId?: string): Promise<void> {\n    try {\n      const existingList = await this.shoppingListRepository.findById(id);\n      if (!existingList) {\n        throw new NotFoundException('Shopping list not found');\n      }\n      if (existingList.userId !== userId) {\n        throw new ForbiddenException('No premission');\n      }\n      await this.shoppingListRepository.delete(id);\n    } catch (error) {\n      if (\n        error instanceof NotFoundException ||\n        error instanceof ForbiddenException\n      ) {\n        throw error;\n      }\n      throw new BadRequestException('Failed to delete shopping list');\n    }\n  }\n\n  private transformToResponseDto(shoppingList: any): ShoppingListResponseDto {\n    return plainToClass(ShoppingListResponseDto, {\n      id: shoppingList.id,\n      title: shoppingList.title,\n      createdBy: shoppingList.createdAt,\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingList/shoppingList.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/controllers/shoppingListItem.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/dto/create-soppingListItem.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/dto/query-soppingListItem.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/dto/response-soppingListItem.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/dto/update-soppingListItem.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/repositories/shoppingListItem.repository.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'prismaService' is assigned a value but never used.","line":8,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Test, TestingModule } from '@nestjs/testing';\nimport { PrismaService } from '../../database/prisma.service';\nimport { ShoppingListItemRepository } from '../repositories/shoppingListItem.repository';\nimport { CreateShoppingListItemDto } from '../dto/create-soppingListItem.dto';\n\ndescribe('ShoppingListItemRepository', () => {\n  let repository: ShoppingListItemRepository;\n  let prismaService: PrismaService;\n\n  const mockPrismaService = {\n    shoppingListItem: {\n      create: jest.fn(),\n      findMany: jest.fn(),\n      findUnique: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn(),\n      deleteMany: jest.fn(),\n      updateMany: jest.fn(),\n      count: jest.fn(),\n    },\n    shoppingList: {\n      count: jest.fn(),\n    },\n    food: {\n      count: jest.fn(),\n    },\n  };\n\n  const mockShoppingListItem = {\n    id: '1',\n    quantity: 2,\n    unit: 'kg',\n    notes: 'Test notes',\n    checked: false,\n    shoppingListId: 'list-1',\n    foodId: 'food-1',\n    createdAt: new Date('2024-01-01'),\n    updatedAt: new Date('2024-01-01'),\n    shoppingList: {\n      id: 'list-1',\n      title: 'Test List',\n      userId: 'user-1',\n    },\n    food: {\n      id: 'food-1',\n      name: 'Test Food',\n      category: 'Test Category',\n      createdAt: new Date('2024-01-01'),\n      updatedAt: new Date('2024-01-01'),\n    },\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        ShoppingListItemRepository,\n        {\n          provide: PrismaService,\n          useValue: mockPrismaService,\n        },\n      ],\n    }).compile();\n\n    repository = module.get<ShoppingListItemRepository>(\n      ShoppingListItemRepository,\n    );\n    prismaService = module.get<PrismaService>(PrismaService);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('create', () => {\n    it('should create a shopping list item with relations', async () => {\n      // Arrange\n      const createDto: CreateShoppingListItemDto = {\n        quantity: 2,\n        unit: 'kg',\n        notes: 'Test notes',\n        checked: false,\n        shoppingListId: 'list-1',\n        foodId: 'food-1',\n      };\n\n      mockPrismaService.shoppingListItem.create.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act\n      const result = await repository.create(createDto);\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.create).toHaveBeenCalledWith({\n        data: createDto,\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n      expect(result).toEqual(mockShoppingListItem);\n      expect(result.shoppingListId).toBeDefined();\n      expect(result.foodId).toBeDefined();\n    });\n  });\n\n  describe('findMany', () => {\n    it('should find items with basic filter', async () => {\n      // Arrange\n      const filter = { shoppingListId: 'list-1' };\n      mockPrismaService.shoppingListItem.findMany.mockResolvedValue([\n        mockShoppingListItem,\n      ]);\n\n      // Act\n      const result = await repository.findMany(filter);\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.findMany).toHaveBeenCalledWith({\n        where: { shoppingListId: 'list-1' },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n        orderBy: [{ checked: 'asc' }, { createdAt: 'desc' }],\n      });\n      expect(result).toEqual([mockShoppingListItem]);\n    });\n\n    it('should find items with complex filter', async () => {\n      // Arrange\n      const filter = {\n        shoppingListId: 'list-1',\n        foodId: 'food-1',\n        checked: false,\n        unit: 'kg',\n        userId: 'user-1',\n      };\n      mockPrismaService.shoppingListItem.findMany.mockResolvedValue([\n        mockShoppingListItem,\n      ]);\n\n      // Act\n      const result = await repository.findMany(filter);\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.findMany).toHaveBeenCalledWith({\n        where: {\n          shoppingListId: 'list-1',\n          foodId: 'food-1',\n          checked: false,\n          unit: { contains: 'kg', mode: 'insensitive' },\n          shoppingList: { userId: 'user-1' },\n        },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n        orderBy: [{ checked: 'asc' }, { createdAt: 'desc' }],\n      });\n      expect(result).toEqual([mockShoppingListItem]);\n    });\n\n    it('should find items with empty filter', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.findMany.mockResolvedValue([\n        mockShoppingListItem,\n      ]);\n\n      // Act\n      const result = await repository.findMany();\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.findMany).toHaveBeenCalledWith({\n        where: {},\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n        orderBy: [{ checked: 'asc' }, { createdAt: 'desc' }],\n      });\n      expect(result).toEqual([mockShoppingListItem]);\n    });\n  });\n\n  describe('findById', () => {\n    it('should find item by id', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.findUnique.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act\n      const result = await repository.findById('1');\n\n      // Assert\n      expect(\n        mockPrismaService.shoppingListItem.findUnique,\n      ).toHaveBeenCalledWith({\n        where: { id: '1' },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n      expect(result).toEqual(mockShoppingListItem);\n    });\n\n    it('should return null if item not found', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.findUnique.mockResolvedValue(null);\n\n      // Act\n      const result = await repository.findById('non-existent');\n\n      // Assert\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('findByShoppingListAndFood', () => {\n    it('should find item by shopping list and food', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.findUnique.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act\n      const result = await repository.findByShoppingListAndFood(\n        'list-1',\n        'food-1',\n      );\n\n      // Assert\n      expect(\n        mockPrismaService.shoppingListItem.findUnique,\n      ).toHaveBeenCalledWith({\n        where: {\n          shoppingListId_foodId: {\n            shoppingListId: 'list-1',\n            foodId: 'food-1',\n          },\n        },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n      expect(result).toEqual(mockShoppingListItem);\n    });\n  });\n\n  describe('update', () => {\n    it('should update item', async () => {\n      // Arrange\n      const updateData = { quantity: 5, checked: true };\n      const updatedItem = { ...mockShoppingListItem, ...updateData };\n      mockPrismaService.shoppingListItem.update.mockResolvedValue(updatedItem);\n\n      // Act\n      const result = await repository.update('1', updateData);\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.update).toHaveBeenCalledWith({\n        where: { id: '1' },\n        data: updateData,\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n      expect(result).toEqual(updatedItem);\n    });\n  });\n\n  describe('toggleChecked', () => {\n    it('should toggle checked status', async () => {\n      // Arrange\n      const currentItem = { checked: false };\n      const toggledItem = { ...mockShoppingListItem, checked: true };\n\n      mockPrismaService.shoppingListItem.findUnique.mockResolvedValue(\n        currentItem,\n      );\n      mockPrismaService.shoppingListItem.update.mockResolvedValue(toggledItem);\n\n      // Act\n      const result = await repository.toggleChecked('1');\n\n      // Assert\n      expect(\n        mockPrismaService.shoppingListItem.findUnique,\n      ).toHaveBeenCalledWith({\n        where: { id: '1' },\n        select: { checked: true },\n      });\n      expect(mockPrismaService.shoppingListItem.update).toHaveBeenCalledWith({\n        where: { id: '1' },\n        data: { checked: true },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n      expect(result).toEqual(toggledItem);\n    });\n\n    it('should throw error if item not found during toggle', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.findUnique.mockResolvedValue(null);\n\n      // Act & Assert\n      await expect(repository.toggleChecked('non-existent')).rejects.toThrow(\n        'Shopping list item not found',\n      );\n    });\n  });\n\n  describe('delete', () => {\n    it('should delete item', async () => {\n      // Arrange\n      mockPrismaService.shoppingListItem.delete.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act\n      await repository.delete('1');\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.delete).toHaveBeenCalledWith({\n        where: { id: '1' },\n      });\n    });\n  });\n\n  describe('clearCheckedItems', () => {\n    it('should clear checked items for shopping list', async () => {\n      // Arrange\n      const deleteResult = { count: 3 };\n      mockPrismaService.shoppingListItem.deleteMany.mockResolvedValue(\n        deleteResult,\n      );\n\n      // Act\n      const result = await repository.clearCheckedItems('list-1', 'user-1');\n\n      // Assert\n      expect(\n        mockPrismaService.shoppingListItem.deleteMany,\n      ).toHaveBeenCalledWith({\n        where: {\n          shoppingListId: 'list-1',\n          checked: true,\n          shoppingList: { userId: 'user-1' },\n        },\n      });\n      expect(result).toEqual(deleteResult);\n    });\n\n    it('should clear checked items without user filter', async () => {\n      // Arrange\n      const deleteResult = { count: 2 };\n      mockPrismaService.shoppingListItem.deleteMany.mockResolvedValue(\n        deleteResult,\n      );\n\n      // Act\n      const result = await repository.clearCheckedItems('list-1');\n\n      // Assert\n      expect(\n        mockPrismaService.shoppingListItem.deleteMany,\n      ).toHaveBeenCalledWith({\n        where: {\n          shoppingListId: 'list-1',\n          checked: true,\n        },\n      });\n      expect(result).toEqual(deleteResult);\n    });\n  });\n\n  describe('count', () => {\n    it('should count items with filter', async () => {\n      // Arrange\n      const filter = { shoppingListId: 'list-1', checked: false };\n      mockPrismaService.shoppingListItem.count.mockResolvedValue(5);\n\n      // Act\n      const result = await repository.count(filter);\n\n      // Assert\n      expect(mockPrismaService.shoppingListItem.count).toHaveBeenCalledWith({\n        where: {\n          shoppingListId: 'list-1',\n          checked: false,\n        },\n      });\n      expect(result).toBe(5);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/repositories/shoppingListItem.repository.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used.","line":57,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@nestjs/common';\nimport { Prisma, ShoppingListItem } from '@prisma/client';\nimport { PrismaService } from '../../database/prisma.service';\nimport { CreateShoppingListItemDto } from '../dto/create-soppingListItem.dto';\nimport { UpdateShoppingListItemDto } from '../dto/update-soppingListItem.dto';\nimport {\n  BaseRepository,\n  FindAllOptions,\n} from 'src/common/interfaces/base-repository.interface';\n\nexport type ShoppingListItemWithRelations = ShoppingListItem & {\n  shoppingList: {\n    id: string;\n    title: string;\n    userId: string;\n  };\n  food: {\n    id: string;\n    name: string;\n    category?: string;\n    createdAt: Date;\n    updatedAt: Date;\n  };\n};\n\nexport interface ShoppingListItemFilter {\n  shoppingListId?: string;\n  foodId?: string;\n  checked?: boolean;\n  unit?: string;\n  userId?: string;\n}\n\n@Injectable()\nexport class ShoppingListItemRepository\n  implements\n    BaseRepository<\n      ShoppingListItem,\n      CreateShoppingListItemDto,\n      UpdateShoppingListItemDto\n    >\n{\n  constructor(private readonly prisma: PrismaService) {}\n\n  async create(\n    data: CreateShoppingListItemDto,\n  ): Promise<ShoppingListItemWithRelations> {\n    return this.prisma.shoppingListItem.create({\n      data,\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n    });\n  }\n\n  findAll(options?: FindAllOptions): Promise<\n    {\n      id: string;\n      quantity: number;\n      unit: string;\n      notes: string | null;\n      checked: boolean;\n      shoppingListId: string;\n      foodId: string;\n      createdAt: Date;\n      updatedAt: Date;\n    }[]\n  > {\n    throw new Error('Method not implemented.');\n  }\n\n  async findMany(\n    filter: ShoppingListItemFilter = {},\n  ): Promise<ShoppingListItemWithRelations[]> {\n    return this.prisma.shoppingListItem.findMany({\n      where: {\n        shoppingListId: filter.shoppingListId,\n        foodId: filter.foodId,\n        checked: filter.checked,\n        unit: filter.unit\n          ? { contains: filter.unit, mode: 'insensitive' }\n          : undefined,\n\n        shoppingList: filter.userId ? { userId: filter.userId } : undefined,\n      },\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n      orderBy: [{ checked: 'asc' }, { createdAt: 'desc' }],\n    });\n  }\n\n  async findByShoppingListId(\n    shoppingListId: string,\n    userId?: string,\n  ): Promise<ShoppingListItemWithRelations[]> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {\n      shoppingListId,\n    };\n\n    // Add user access control if userId provided\n    if (userId) {\n      whereConditions.shoppingList = {\n        userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.findMany({\n      where: whereConditions,\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n      orderBy: [\n        { checked: 'asc' }, // Unchecked items first\n        { createdAt: 'desc' },\n      ],\n    });\n  }\n\n  async findById(id: string): Promise<ShoppingListItemWithRelations | null> {\n    return this.prisma.shoppingListItem.findUnique({\n      where: { id },\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n    });\n  }\n\n  async findByShoppingListAndFood(\n    shoppingListId: string,\n    foodId: string,\n  ): Promise<ShoppingListItemWithRelations | null> {\n    return this.prisma.shoppingListItem.findUnique({\n      where: {\n        shoppingListId_foodId: {\n          shoppingListId,\n          foodId,\n        },\n      },\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n    });\n  }\n\n  async update(\n    id: string,\n    data: Prisma.ShoppingListItemUpdateInput,\n  ): Promise<ShoppingListItemWithRelations> {\n    return this.prisma.shoppingListItem.update({\n      where: { id },\n      data,\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n    });\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.prisma.shoppingListItem.delete({\n      where: { id },\n    });\n  }\n\n  async deleteMany(filter: ShoppingListItemFilter): Promise<{ count: number }> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {};\n\n    if (filter.shoppingListId) {\n      whereConditions.shoppingListId = filter.shoppingListId;\n    }\n\n    if (filter.checked !== undefined) {\n      whereConditions.checked = filter.checked;\n    }\n\n    if (filter.userId) {\n      whereConditions.shoppingList = {\n        userId: filter.userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.deleteMany({\n      where: whereConditions,\n    });\n  }\n\n  async count(filter: ShoppingListItemFilter = {}): Promise<number> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {};\n\n    if (filter.shoppingListId) {\n      whereConditions.shoppingListId = filter.shoppingListId;\n    }\n\n    if (filter.foodId) {\n      whereConditions.foodId = filter.foodId;\n    }\n\n    if (filter.checked !== undefined) {\n      whereConditions.checked = filter.checked;\n    }\n\n    if (filter.userId) {\n      whereConditions.shoppingList = {\n        userId: filter.userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.count({\n      where: whereConditions,\n    });\n  }\n\n  async toggleChecked(id: string): Promise<ShoppingListItemWithRelations> {\n    // First get the current checked state\n    const currentItem = await this.prisma.shoppingListItem.findUnique({\n      where: { id },\n      select: { checked: true },\n    });\n\n    if (!currentItem) {\n      throw new Error('Shopping list item not found');\n    }\n\n    return this.prisma.shoppingListItem.update({\n      where: { id },\n      data: {\n        checked: !currentItem.checked,\n      },\n      include: {\n        shoppingList: true,\n        food: true,\n      },\n    });\n  }\n\n  async clearCheckedItems(\n    shoppingListId: string,\n    userId?: string,\n  ): Promise<{ count: number }> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {\n      shoppingListId,\n      checked: true,\n    };\n\n    if (userId) {\n      whereConditions.shoppingList = {\n        userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.deleteMany({\n      where: whereConditions,\n    });\n  }\n\n  async markAllAsChecked(\n    shoppingListId: string,\n    userId?: string,\n  ): Promise<{ count: number }> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {\n      shoppingListId,\n      checked: false,\n    };\n\n    if (userId) {\n      whereConditions.shoppingList = {\n        userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.updateMany({\n      where: whereConditions,\n      data: {\n        checked: true,\n      },\n    });\n  }\n\n  async markAllAsUnchecked(\n    shoppingListId: string,\n    userId?: string,\n  ): Promise<{ count: number }> {\n    const whereConditions: Prisma.ShoppingListItemWhereInput = {\n      shoppingListId,\n      checked: true,\n    };\n\n    if (userId) {\n      whereConditions.shoppingList = {\n        userId,\n      };\n    }\n\n    return this.prisma.shoppingListItem.updateMany({\n      where: whereConditions,\n      data: {\n        checked: false,\n      },\n    });\n  }\n\n  async validateShoppingListExists(\n    shoppingListId: string,\n    userId: string,\n  ): Promise<boolean> {\n    const count = await this.prisma.shoppingList.count({\n      where: {\n        id: shoppingListId,\n        userId: userId,\n      },\n    });\n    return count > 0;\n  }\n\n  async validateFoodExists(foodId: string): Promise<boolean> {\n    const count = await this.prisma.food.count({\n      where: { id: foodId },\n    });\n    return count > 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/services/shoppingListItem.service.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'prismaService' is assigned a value but never used.","line":18,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Test, TestingModule } from '@nestjs/testing';\nimport {\n  NotFoundException,\n  BadRequestException,\n  ForbiddenException,\n  ConflictException,\n} from '@nestjs/common';\nimport { ShoppingListItemService } from '../services/shoppingListItem.service';\nimport { PrismaService } from '../../database/prisma.service';\nimport { ShoppingListItemRepository } from '../repositories/shoppingListItem.repository';\nimport { CreateShoppingListItemDto } from '../dto/create-soppingListItem.dto';\nimport { UpdateShoppingListItemDto } from '../dto/update-soppingListItem.dto';\nimport { QueryShoppingListItemDto } from '../dto/query-soppingListItem.dto';\n\ndescribe('ShoppingListItemService', () => {\n  let service: ShoppingListItemService;\n  let repository: jest.Mocked<ShoppingListItemRepository>;\n  let prismaService: PrismaService;\n\n  const mockPrismaService = {\n    shoppingList: {\n      findFirst: jest.fn(),\n    },\n    food: {\n      findUnique: jest.fn(),\n    },\n    shoppingListItem: {\n      create: jest.fn(),\n    },\n  };\n\n  const mockShoppingListItem = {\n    id: '1',\n    quantity: 2,\n    unit: 'kg',\n    notes: null,\n    checked: false,\n    shoppingListId: 'list-1',\n    foodId: 'food-1',\n    createdAt: new Date('2024-01-01'),\n    updatedAt: new Date('2024-01-01'),\n    shoppingList: {\n      id: 'list-1',\n      title: 'Test List',\n      userId: 'user-1',\n    },\n    food: {\n      id: 'food-1',\n      name: 'Test Food',\n      category: 'Test Category',\n      createdAt: new Date('2024-01-01'),\n      updatedAt: new Date('2024-01-01'),\n    },\n  };\n\n  const mockShoppingList = {\n    id: 'list-1',\n    title: 'Test List',\n    userId: 'user-1',\n  };\n\n  const mockFood = {\n    id: 'food-1',\n    name: 'Test Food',\n  };\n\n  beforeEach(async () => {\n    const mockRepository = {\n      create: jest.fn(),\n      findMany: jest.fn(),\n      findByShoppingListId: jest.fn(),\n      findById: jest.fn(),\n      findByShoppingListAndFood: jest.fn(),\n      update: jest.fn(),\n      toggleChecked: jest.fn(),\n      delete: jest.fn(),\n      clearCheckedItems: jest.fn(),\n    };\n\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        ShoppingListItemService,\n        {\n          provide: ShoppingListItemRepository,\n          useValue: mockRepository,\n        },\n        {\n          provide: PrismaService,\n          useValue: mockPrismaService,\n        },\n      ],\n    }).compile();\n\n    service = module.get<ShoppingListItemService>(ShoppingListItemService);\n    repository = module.get(ShoppingListItemRepository);\n    prismaService = module.get<PrismaService>(PrismaService);\n\n    // Mock logger to avoid undefined errors\n    service.logger = { log: jest.fn() };\n\n    // Mock die Transformation mit korrektem Typing\n    jest\n      .spyOn(service, 'transformToResponseDto' as any)\n      .mockImplementation((item: any) => ({\n        id: item.id,\n        quantity: item.quantity,\n        unit: item.unit,\n        notes: item.notes === null ? undefined : item.notes,\n        checked: item.checked,\n        shoppingListId: item.shoppingListId,\n        foodId: item.foodId,\n        shoppingList: item.shoppingList,\n        food: item.food,\n      }));\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('create', () => {\n    const createDto: CreateShoppingListItemDto = {\n      quantity: 2,\n      unit: 'kg',\n      notes: 'Test notes',\n      checked: false,\n      shoppingListId: 'list-1',\n      foodId: 'food-1',\n    };\n\n    it('should create a shopping list item successfully', async () => {\n      // Arrange\n      // Mock die Prisma-Aufrufe für die Validierungen\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(\n        mockShoppingList,\n      );\n      mockPrismaService.food.findUnique.mockResolvedValue(mockFood);\n      repository.findByShoppingListAndFood.mockResolvedValue(null);\n      mockPrismaService.shoppingListItem.create.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act\n      const result = await service.create(createDto, 'user-1');\n\n      // Assert\n      expect(mockPrismaService.shoppingList.findFirst).toHaveBeenCalledWith({\n        where: { id: 'list-1', userId: 'user-1' },\n      });\n      expect(mockPrismaService.food.findUnique).toHaveBeenCalledWith({\n        where: { id: 'food-1' },\n      });\n      expect(repository.findByShoppingListAndFood).toHaveBeenCalledWith(\n        'list-1',\n        'food-1',\n      );\n      expect(mockPrismaService.shoppingListItem.create).toHaveBeenCalledWith({\n        data: {\n          quantity: 2,\n          unit: 'kg',\n          notes: 'Test notes',\n          checked: false,\n          shoppingListId: 'list-1',\n          foodId: 'food-1',\n        },\n        include: {\n          shoppingList: true,\n          food: true,\n        },\n      });\n\n      expect(result.id).toBe('1');\n      expect(result.quantity).toBe(2);\n    });\n\n    it('should throw NotFoundException if shopping list not found', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(null);\n\n      // Act & Assert\n      await expect(service.create(createDto, 'user-1')).rejects.toThrow(\n        NotFoundException,\n      );\n\n      // Stelle sicher, dass nachfolgende Schritte nicht ausgeführt werden\n      expect(mockPrismaService.food.findUnique).not.toHaveBeenCalled();\n      expect(repository.findByShoppingListAndFood).not.toHaveBeenCalled();\n    });\n\n    it('should throw NotFoundException if food not found', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(\n        mockShoppingList,\n      );\n      mockPrismaService.food.findUnique.mockResolvedValue(null);\n\n      // Act & Assert\n      await expect(service.create(createDto, 'user-1')).rejects.toThrow(\n        NotFoundException,\n      );\n    });\n\n    it('should throw ConflictException if item already exists', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(\n        mockShoppingList,\n      );\n      mockPrismaService.food.findUnique.mockResolvedValue(mockFood);\n      repository.findByShoppingListAndFood.mockResolvedValue(\n        mockShoppingListItem,\n      );\n\n      // Act & Assert\n      await expect(service.create(createDto, 'user-1')).rejects.toThrow(\n        ConflictException,\n      );\n\n      // Stelle sicher, dass create nicht aufgerufen wird, wenn Item bereits existiert\n      expect(mockPrismaService.shoppingListItem.create).not.toHaveBeenCalled();\n    });\n\n    it('should throw BadRequestException on repository error', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(\n        mockShoppingList,\n      );\n      mockPrismaService.food.findUnique.mockResolvedValue(mockFood);\n      repository.findByShoppingListAndFood.mockResolvedValue(null);\n      mockPrismaService.shoppingListItem.create.mockRejectedValue(\n        new Error('Database error'),\n      );\n\n      // Act & Assert\n      await expect(service.create(createDto, 'user-1')).rejects.toThrow(\n        BadRequestException,\n      );\n    });\n  });\n\n  describe('findAll', () => {\n    it('should return all shopping list items with filters', async () => {\n      // Arrange\n      const query: QueryShoppingListItemDto = {\n        shoppingListId: 'list-1',\n        checked: false,\n      };\n\n      // Mock die Rückgabe so, wie sie der Service tatsächlich strukturiert\n      repository.findMany.mockResolvedValue([mockShoppingListItem]);\n\n      // Act\n      const result = await service.findAll(query);\n\n      // Assert\n      expect(repository.findMany).toHaveBeenCalledWith({\n        shoppingListId: 'list-1',\n        foodId: undefined,\n        checked: false,\n        unit: undefined,\n      });\n      expect(result.data).toHaveLength(1);\n      expect(result.data[0]).toHaveProperty('id');\n    });\n\n    it('should handle unit filter with case-insensitive search', async () => {\n      // Arrange\n      const query: QueryShoppingListItemDto = {\n        unit: 'KG',\n      };\n      repository.findMany.mockResolvedValue([mockShoppingListItem]);\n\n      // Act\n      const result = await service.findAll(query);\n\n      // Assert\n      expect(repository.findMany).toHaveBeenCalledWith({\n        shoppingListId: undefined,\n        foodId: undefined,\n        checked: undefined,\n        unit: 'KG',\n      });\n      expect(result.data).toHaveLength(1);\n    });\n  });\n\n  describe('findByShoppingList', () => {\n    it('should return items for a shopping list', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(\n        mockShoppingList,\n      );\n      repository.findByShoppingListId.mockResolvedValue([mockShoppingListItem]);\n\n      // Act\n      const result = await service.findByShoppingList('list-1', 'user-1');\n\n      // Assert\n      expect(mockPrismaService.shoppingList.findFirst).toHaveBeenCalledWith({\n        where: { id: 'list-1', userId: 'user-1' },\n      });\n      expect(repository.findByShoppingListId).toHaveBeenCalledWith(\n        'list-1',\n        'user-1',\n      );\n      expect(result.data).toHaveLength(1);\n    });\n\n    it('should throw NotFoundException when shopping list not found', async () => {\n      // Arrange\n      mockPrismaService.shoppingList.findFirst.mockResolvedValue(null);\n\n      // Act & Assert\n      await expect(\n        service.findByShoppingList('list-1', 'user-1'),\n      ).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('findById', () => {\n    it('should return a shopping list item by id', async () => {\n      // Arrange\n      repository.findById.mockResolvedValue(mockShoppingListItem);\n\n      // Act\n      const result = await service.findById('1', 'user-1');\n\n      // Assert\n      expect(repository.findById).toHaveBeenCalledWith('1');\n      expect(result).toHaveProperty('id');\n      // Passe je nach tatsächlicher Transformation an:\n      // expect(result.notes).toBeUndefined(); // falls notes transformiert wird\n    });\n\n    it('should throw NotFoundException when item not found', async () => {\n      // Arrange\n      repository.findById.mockResolvedValue(null);\n\n      // Act & Assert\n      await expect(service.findById('1', 'user-1')).rejects.toThrow(\n        NotFoundException,\n      );\n    });\n\n    it('should throw ForbiddenException when user does not have access', async () => {\n      // Arrange\n      const itemWithDifferentUser = {\n        ...mockShoppingListItem,\n        shoppingList: {\n          ...mockShoppingListItem.shoppingList,\n          userId: 'other-user',\n        },\n      };\n      repository.findById.mockResolvedValue(itemWithDifferentUser);\n\n      // Act & Assert\n      await expect(service.findById('1', 'user-1')).rejects.toThrow(\n        ForbiddenException,\n      );\n    });\n  });\n\n  describe('update', () => {\n    it('should update a shopping list item', async () => {\n      const itemId = 'item-1';\n      const userId = 'user-1';\n      const updateDto: UpdateShoppingListItemDto = {\n        quantity: 5,\n        checked: true,\n      };\n\n      const updatedItem = {\n        ...mockShoppingListItem,\n        quantity: 5,\n        checked: true,\n      };\n\n      repository.findById.mockResolvedValue(mockShoppingListItem);\n      repository.update.mockResolvedValue(updatedItem);\n\n      const result = await service.update(itemId, updateDto, userId);\n\n      expect(repository.findById).toHaveBeenCalledWith(itemId);\n      expect(repository.update).toHaveBeenCalledWith(itemId, updateDto);\n      expect(result.quantity).toBe(5);\n      expect(result.checked).toBe(true);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/services/shoppingListItem.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/shoppingListItem/shoppingListItem.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/controllers/user.controller.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/dto/create-user.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/dto/update-user.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/dto/user-preferences.dto.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/repositories/user.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/src/user/user.module.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/app.e2e-spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/cache.e2e-spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/e2e-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/integration-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/seeding.e2e-spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/lavinia/Dokumente/git/foodmission-data-framework/test/setup.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":115,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":120,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]